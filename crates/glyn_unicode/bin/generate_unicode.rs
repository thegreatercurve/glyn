use std::collections::HashSet;
use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    let args: Vec<String> = env::args().collect();

    let mut output = None;
    let mut version = None;

    for arg in &args[1..] {
        if let Some(rest) = arg.strip_prefix("--output=").or(arg.strip_prefix("-o=")) {
            output = Some(rest.to_string());
        } else if let Some(rest) = arg.strip_prefix("--version=").or(arg.strip_prefix("-v=")) {
            version = Some(rest.to_string());
        } else {
            eprintln!("Unknown argument: {}", arg);

            std::process::exit(1);
        }
    }

    let Some(output) = output else {
        eprintln!("Output file is required");

        std::process::exit(1);
    };

    let version = version.unwrap_or_else(|| "UNIDATA".to_string());

    let contents = download_derived_core_properties(&version).unwrap();

    println!("Extracting data from file...");

    let start_code_points = extract_derived_core_properties(&contents, "ID_Start");
    let continue_code_points = extract_derived_core_properties(&contents, "ID_Continue");

    println!("Data extracted from file");

    let version_str = extract_version(&contents).unwrap();

    write_rust_file(
        &output,
        &start_code_points,
        &continue_code_points,
        &version_str,
    )
    .unwrap();
}

const BASE_URL: &str = "https://unicode.org/Public";
const FILENAME: &str = "DerivedCoreProperties.txt";

fn download_derived_core_properties(version: &str) -> Result<String, Box<dyn std::error::Error>> {
    let url = if version == "UNIDATA" {
        format!("{}/{}/{}", BASE_URL, version, FILENAME)
    } else {
        format!("{}/{}/ucd/{}", BASE_URL, version, FILENAME)
    };

    println!("Downloading `{}`...", url);

    let resp = reqwest::blocking::get(&url)?;

    let text = resp.text()?;

    println!("Finished downloading `{}`", url);

    Ok(text)
}

fn extract_derived_core_properties(file_contents: &str, derived_property: &str) -> HashSet<String> {
    let mut code_points = HashSet::new();

    for row in file_contents.lines() {
        if row.is_empty() || row.starts_with('#') {
            continue;
        }

        let mut parts = row.split('#').next().unwrap().split(';');
        let code_point_range = parts.next().unwrap().trim();
        let property = parts.next().unwrap().trim();

        if property != derived_property {
            continue;
        }

        code_points.insert(code_point_range.to_string());
    }
    code_points
}

fn extract_version(file_contents: &str) -> Option<String> {
    let re = regex::Regex::new(r"DerivedCoreProperties-(\d+\.\d+\.\d+).txt").unwrap();

    re.captures(file_contents)
        .and_then(|cap| cap.get(1).map(|m| m.as_str().to_string()))
}

fn write_rust_file(
    output: &str,
    start_code_points: &HashSet<String>,
    continue_code_points: &HashSet<String>,
    version: &str,
) -> std::io::Result<()> {
    println!("Creating file at: `{}`...", output);

    let mut data = generate_pragma(version);

    data.push_str(
        format!(
            r#"
pub fn is_unicode_id_start(ch: char) -> bool {{
    matches!(ch, {}
    )
}}

pub fn is_unicode_id_continue(ch: char) -> bool {{
    if is_unicode_id_start(ch) {{
        return true;
    }}

    matches!(ch, {}
    )
}}
"#,
            get_code_points(start_code_points),
            get_code_points(&remove_duplicate_code_points(
                start_code_points,
                continue_code_points,
            )),
        )
        .as_str(),
    );

    let path = Path::new(output);

    let mut file = fs::File::create(path)?;

    file.write_all(data.as_bytes())?;

    println!("Finished creating file at: `{}`...", output);

    Ok(())
}

fn get_code_points(code_points: &HashSet<String>) -> String {
    let mut formatted = Vec::new();

    for code_point in code_points {
        if code_point.contains("..") {
            let mut parts = code_point.split("..");

            let start = parts.next().unwrap();
            let end = parts.next().unwrap();

            formatted.push(format!("'\\u{{{}}}'..='\\u{{{}}}'", start, end));
        } else {
            formatted.push(format!("'\\u{{{}}}'", code_point));
        }
    }

    formatted.sort();

    formatted.join("\n        | ")
}

fn generate_pragma(version: &str) -> String {
    format!(
        r#"#[rustfmt::skip]
/**
 * This file is generated. Do not modify it manually!
 *
 * This file was generated by: `generate_unicode`
 *
 * Unicode Version:
 *   {}
 */"#,
        version
    )
}

fn remove_duplicate_code_points(
    code_points_one: &HashSet<String>,
    code_points_two: &HashSet<String>,
) -> HashSet<String> {
    let mut output = HashSet::new();

    for code_point in code_points_two {
        if !code_points_one.contains(code_point) {
            output.insert(code_point.clone());
        }
    }

    output
}
